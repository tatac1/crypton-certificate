{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module TestACValidation where

import Control.Monad
import Data.ASN1.BitArray
import Data.ASN1.Types
import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as BC
import Data.Hourglass
import Data.List (nub)
import Data.X509
import Data.X509.AC.Validation
import Data.X509.AttCert
import Data.X509.Attribute
import Test.Tasty
import Test.Tasty.QuickCheck

-- | Helper: generate a ByteString of random length within [r1, r2].
--
-- Used to produce arbitrary binary data for ASN.1 fields such as
-- ObjectDigestInfo.odiObjectDigest (RFC 5755 §4.2.2, Holder SEQUENCE),
-- IssuerSerial.issuerUID (RFC 5755 §4.2.2, UniqueIdentifier BIT STRING),
-- and other OCTET STRING / BIT STRING fields.
--
-- The generated ByteString length is uniformly distributed in [r1, r2],
-- which ensures that edge cases (minimum and maximum length) are exercised.
arbitraryBS :: Int -> Int -> Gen B.ByteString
arbitraryBS r1 r2 = choose (r1, r2) >>= \l -> (B.pack <$> replicateM l arbitrary)

-- | Helper: generate a non-empty list of arbitrary elements.
--
-- This is a thin wrapper around QuickCheck's listOf1 that produces a list
-- with at least one element.  It is used throughout this module wherever
-- RFC 5755 requires a SEQUENCE OF with at least one member, e.g.:
--
--   GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
--                                                  (RFC 5280 §4.2.1.6)
--
-- By giving the wrapper a descriptive name, call sites self-document the
-- non-emptiness invariant mandated by the standard.
listOf1NonEmpty :: Gen a -> Gen [a]
listOf1NonEmpty = listOf1

-- Arbitrary instances for common types

-- | Arbitrary instance for AltName (RFC 5755 §4.2.2, §4.2.3)
--
-- RFC 5755 references GeneralName from RFC 5280:
--   GeneralName ::= CHOICE {
--     otherName                  [0]  AnotherName,
--     rfc822Name                 [1]  IA5String,
--     dNSName                    [2]  IA5String,
--     x400Address                [3]  ORAddress,
--     directoryName              [4]  Name,
--     ediPartyName               [5]  EDIPartyName,
--     uniformResourceIdentifier  [6]  IA5String,
--     iPAddress                  [7]  OCTET STRING,
--     registeredID               [8]  OBJECT IDENTIFIER
--   }
--
-- This instance generates 7 of the 9 variants: rfc822Name, dNSName, URI,
-- iPAddress, XMPP, DNSSRV, and directoryName. The otherName, x400Address,
-- ediPartyName, and registeredID variants are not generated.
--
-- Expected: All generated variants should roundtrip through GeneralName
--   encoding/decoding without loss.
-- NOT generated: otherName [0] (except XMPP/DNSSRV), x400Address [3],
--   ediPartyName [5], registeredID [8].
instance Arbitrary AltName where
  arbitrary = do
    printable <- getASCIIString <$> arbitrary
    oneof
      [ pure $ AltNameRFC822 printable,
        pure $ AltNameDNS printable,
        pure $ AltNameURI printable,
        AltNameIP <$> arbitraryBS 4 4,
        pure $ AltNameXMPP printable,
        pure $ AltNameDNSSRV printable,
        AltDirectoryName <$> arbitrary
      ]

-- | Arbitrary instance for DistinguishedName (RFC 5755 §4.2.3, RFC 5280 §4.1.2.4)
--
-- RFC 5280 defines:
--   Name ::= CHOICE { rdnSequence  RDNSequence }
--   RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
--   RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue
--
-- This instance generates a single-RDN DistinguishedName with one
-- CommonName (OID 2.5.4.3) attribute encoded as UTF8String.  This is
-- sufficient for testing AC issuer identification (RFC 5755 §4.2.3:
-- "issuerName MUST contain one and only one GeneralName of type
-- directoryName") and holder entity names.
--
-- Expected: The generated DN always has exactly one non-empty RDN.
-- NOT generated: multi-RDN names, non-CN attributes, or empty DNs.
instance Arbitrary DistinguishedName where
  arbitrary = do
    cn <- getASCIIString <$> arbitrary
    let rdn = (getObjectID DnCommonName, ASN1CharacterString UTF8 (BC.pack cn))
    return $ DistinguishedName [rdn]

-- | Helper: generate a DateTime within a reasonable calendar range.
--
-- RFC 5755 §4.2.6 (AttCertValidityPeriod) uses GeneralizedTime:
--   AttCertValidityPeriod ::= SEQUENCE {
--     notBeforeTime  GeneralizedTime,
--     notAfterTime   GeneralizedTime
--   }
--
-- GeneralizedTime (X.680 §46) can represent any date, but we constrain
-- generation to years 1970–2070, days 1–28 (avoiding month-length edge
-- cases), and full second precision.  This keeps the generated values
-- realistic while avoiding calendar-arithmetic corner cases that are
-- outside the scope of RFC 5755 profile validation.
genReasonableDateTime :: Gen DateTime
genReasonableDateTime = do
  year <- choose (1970, 2070)
  month <- elements [January .. December]
  day <- choose (1, 28)
  hour <- choose (0, 23)
  minute <- choose (0, 59)
  second <- choose (0, 59)
  let tod = TimeOfDay (Hours hour) (Minutes minute) (Seconds second) (NanoSeconds 0)
  return $ DateTime (Date year month day) tod

-- | Helper: generate an AttCertValidityPeriod with notBefore < notAfter.
--
-- RFC 5755 §4.2.6:
--   AttCertValidityPeriod ::= SEQUENCE {
--     notBeforeTime  GeneralizedTime,
--     notAfterTime   GeneralizedTime
--   }
--
-- The duration between notBeforeTime and notAfterTime is uniformly
-- chosen between 1 second and ~10 years (315 576 000 seconds), ensuring
-- that the validity window is always non-degenerate (notBefore < notAfter).
-- This invariant is required for meaningful temporal validation of ACs.
genValidity :: Gen AttCertValidityPeriod
genValidity = do
  start <- genReasonableDateTime
  duration <- choose (1, 315576000)
  let end = timeAdd start (Seconds duration)
  return $ AttCertValidityPeriod start end

-- | Arbitrary instance for AttCertValidityPeriod (RFC 5755 §4.2.6)
--
-- Delegates to genValidity which guarantees notBeforeTime < notAfterTime.
-- See genValidity for details on the generation strategy.
instance Arbitrary AttCertValidityPeriod where
  arbitrary = genValidity

-- | Arbitrary instance for DigestedObjectType (RFC 5755 §4.2.2)
--
-- RFC 5755 §4.2.2 defines ObjectDigestInfo within the Holder:
--   ObjectDigestInfo ::= SEQUENCE {
--     digestedObjectType  ENUMERATED {
--       publicKey            (0),
--       publicKeyCert        (1),
--       otherObjectTypes     (2)
--     },
--     otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
--     digestAlgorithm      AlgorithmIdentifier,
--     objectDigest         BIT STRING
--   }
--
-- This instance generates all three enumerated values uniformly.
-- When digestedObjectType is otherObjectTypes (2), the ObjectDigestInfo
-- Arbitrary instance below will populate otherObjectTypeID.
instance Arbitrary DigestedObjectType where
  arbitrary = elements [OIDPublicKey, OIDPublicKeyCert, OIDOtherObjectTypes]

-- | Arbitrary instance for SignatureALG
--
-- RFC 5755 §8 (Security Considerations) does not mandate a specific
-- algorithm but references RFC 5280 AlgorithmIdentifier.  In practice,
-- ACs should use SHA-256 or stronger.  This instance generates five
-- RSA-based signature algorithms to exercise the profile validator's
-- handling of:
--
--   - MD5withRSA     -> must be rejected  (WeakSignatureAlgorithm)
--   - SHA1withRSA    -> should warn        (DeprecatedSignatureAlgorithm)
--   - SHA256withRSA  -> accepted
--   - SHA384withRSA  -> accepted
--   - SHA512withRSA  -> accepted
--
-- NOT generated: ECDSA, DSA, or EdDSA-based algorithms.
instance Arbitrary SignatureALG where
  arbitrary =
    elements
      [ SignatureALG HashSHA1 PubKeyALG_RSA,
        SignatureALG HashMD5 PubKeyALG_RSA,
        SignatureALG HashSHA256 PubKeyALG_RSA,
        SignatureALG HashSHA384 PubKeyALG_RSA,
        SignatureALG HashSHA512 PubKeyALG_RSA
      ]

-- | Arbitrary instance for ObjectDigestInfo (RFC 5755 §4.2.2)
--
-- RFC 5755 §4.2.2 (Holder):
--   ObjectDigestInfo ::= SEQUENCE {
--     digestedObjectType  ENUMERATED { publicKey(0), publicKeyCert(1),
--                                      otherObjectTypes(2) },
--     otherObjectTypeID   OBJECT IDENTIFIER OPTIONAL,
--     digestAlgorithm     AlgorithmIdentifier,
--     objectDigest        BIT STRING
--   }
--
-- Per the ASN.1 constraint, otherObjectTypeID is present only when
-- digestedObjectType is otherObjectTypes (2); otherwise it is Nothing.
-- The objectDigest field is a random 16–32 byte BIT STRING, simulating
-- a cryptographic hash value.
--
-- Expected: The otherObjectTypeID/digestedObjectType invariant is maintained.
-- NOT generated: Real cryptographic digests or algorithm-consistent lengths.
instance Arbitrary ObjectDigestInfo where
  arbitrary = do
    dot <- arbitrary
    moid <- case dot of
      OIDOtherObjectTypes -> Just <$> arbitrary
      _ -> pure Nothing
    ObjectDigestInfo dot moid <$> arbitrary <*> arbitraryBS 16 32

-- | Helper: optionally generate a UniqueIdentifier BIT STRING.
--
-- RFC 5755 §4.2.2 (IssuerSerial):
--   IssuerSerial ::= SEQUENCE {
--     issuer     GeneralNames,
--     serial     CertificateSerialNumber,
--     issuerUID  UniqueIdentifier OPTIONAL
--   }
--
-- UniqueIdentifier is defined as BIT STRING in RFC 5280 §4.1.2.8.
-- This generator produces Nothing (absent) or Just a random 1–8 byte
-- BIT STRING with 50/50 probability, exercising both the present and
-- absent cases of this OPTIONAL field.
genMaybeUniqueID :: Gen (Maybe UniqueID)
genMaybeUniqueID = do
  hasUID <- arbitrary
  if hasUID
    then Just <$> (toBitArray <$> arbitraryBS 1 8 <*> pure 0)
    else pure Nothing

-- | Arbitrary instance for IssuerSerial (RFC 5755 §4.2.2)
--
-- RFC 5755 §4.2.2 (Holder):
--   IssuerSerial ::= SEQUENCE {
--     issuer     GeneralNames,
--     serial     CertificateSerialNumber,
--     issuerUID  UniqueIdentifier OPTIONAL
--   }
--
-- The issuer field is a non-empty list of GeneralNames (SEQUENCE SIZE
-- (1..MAX)).  The serial is always positive (CertificateSerialNumber is
-- INTEGER, guaranteed positive by Positive wrapper).  issuerUID is
-- optionally generated via genMaybeUniqueID.
--
-- Expected: issuer is never empty, serial > 0.
instance Arbitrary IssuerSerial where
  arbitrary = IssuerSerial
    <$> listOf1NonEmpty arbitrary
    <*> (getPositive <$> arbitrary)
    <*> genMaybeUniqueID

-- | Helper: optionally generate a non-empty list of GeneralNames.
--
-- Used for the entityName field of the Holder (RFC 5755 §4.2.2):
--   Holder ::= SEQUENCE {
--     baseCertificateID   [0] IssuerSerial OPTIONAL,
--     entityName          [1] GeneralNames OPTIONAL,
--     objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
--   }
--
-- When present, GeneralNames must contain at least one GeneralName
-- (SEQUENCE SIZE (1..MAX) per RFC 5280 §4.2.1.6).  This generator
-- produces Nothing or Just (non-empty list) with 50/50 probability.
genMaybeGeneralNames :: Gen (Maybe [AltName])
genMaybeGeneralNames = do
  hasNames <- arbitrary
  if hasNames
    then Just <$> listOf1NonEmpty arbitrary
    else pure Nothing

-- | Arbitrary instance for Holder (RFC 5755 §4.2.2)
--
-- RFC 5755 §4.2.2:
--   Holder ::= SEQUENCE {
--     baseCertificateID   [0] IssuerSerial OPTIONAL,
--     entityName          [1] GeneralNames OPTIONAL,
--     objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
--   }
--
-- Per RFC 5755: "At least one of the three options MUST be used for any
-- given AC."  This instance generates all three fields independently
-- (each may be Nothing).  If all three happen to be Nothing, the
-- generator forces exactly one field to be present by choosing uniformly
-- among the three alternatives.
--
-- Expected: The generated Holder always has at least one non-Nothing field.
-- NOT generated: Holders where all three fields are simultaneously Nothing
--   (this is explicitly prevented by the fallback logic).
instance Arbitrary Holder where
  arbitrary = do
    mBaseCertID <- arbitrary
    mEntityName <- genMaybeGeneralNames
    mObjDigestInfo <- arbitrary
    if all isNothing [fmap (const ()) mBaseCertID, fmap (const ()) mEntityName, fmap (const ()) mObjDigestInfo]
      then oneof
        [ Holder <$> (Just <$> arbitrary) <*> pure Nothing <*> pure Nothing,
          Holder <$> pure Nothing <*> (Just <$> listOf1NonEmpty arbitrary) <*> pure Nothing,
          Holder <$> pure Nothing <*> pure Nothing <*> (Just <$> arbitrary)
        ]
      else pure $ Holder mBaseCertID mEntityName mObjDigestInfo
    where
      isNothing Nothing = True
      isNothing _ = False

-- | Helper: generate the issuerName field for a V2Form issuer.
--
-- RFC 5755 §4.2.3:
--   "ACs conforming to this profile MUST use the v2Form choice,
--    which MUST contain one and only one GeneralName in the issuerName,
--    and that GeneralName MUST be of type directoryName."
--
-- This generator produces a singleton list containing an AltDirectoryName
-- whose DistinguishedName has at least one RDN (guaranteed by suchThat),
-- satisfying both the "one and only one" and "directoryName" requirements.
--
-- Expected: Exactly one GeneralName of type directoryName with non-empty DN.
-- NOT generated: Empty DNs, multiple GeneralNames, or non-directoryName types.
genV2FormIssuerName :: Gen [AltName]
genV2FormIssuerName = do
  dn <- suchThat arbitrary (\(DistinguishedName l) -> not (null l))
  return [AltDirectoryName dn]

-- | Arbitrary instance for V2Form (RFC 5755 §4.2.3)
--
-- RFC 5755 §4.2.3:
--   V2Form ::= SEQUENCE {
--     issuerName            GeneralNames  OPTIONAL,
--     baseCertificateID     [0] IssuerSerial  OPTIONAL,
--     objectDigestInfo      [1] ObjectDigestInfo  OPTIONAL
--   }
--
-- Per the profile, issuerName MUST be present with exactly one
-- directoryName.  baseCertificateID and objectDigestInfo MUST NOT be
-- present in conforming ACs (RFC 5755 §4.2.3: "baseCertificateID and
-- objectDigestInfo MUST NOT be present").  This instance generates
-- issuerName via genV2FormIssuerName (always conforming) but allows
-- the other two fields to be arbitrary, so that the profile validator
-- can be tested with both conforming and non-conforming inputs.
instance Arbitrary V2Form where
  arbitrary = V2Form
    <$> genV2FormIssuerName
    <*> arbitrary
    <*> arbitrary

-- | Arbitrary instance for AttCertIssuer (RFC 5755 §4.2.3)
--
-- RFC 5755 §4.2.3:
--   AttCertIssuer ::= CHOICE {
--     v1Form   GeneralNames,     -- MUST NOT be used in this profile
--     v2Form   [0] V2Form        -- v2 only
--   }
--
-- This instance always generates the v2Form choice (AttCertIssuerV2),
-- which is the only form permitted by the RFC 5755 profile.  The v1Form
-- case is deliberately omitted here; it is tested separately in
-- prop_v1Form_rejected by constructing AttCertIssuerV1 directly.
instance Arbitrary AttCertIssuer where
  arbitrary = AttCertIssuerV2 <$> arbitrary

-- | Arbitrary instance for RoleSyntax (RFC 5755 §4.4.5)
--
-- RFC 5755 §4.4.5:
--   RoleSyntax ::= SEQUENCE {
--     roleAuthority  [0] GeneralNames OPTIONAL,
--     roleName       [1] GeneralName
--   }
--
-- Per RFC 5755: "roleName MUST be present and roleName MUST use the
-- uniformResourceIdentifier CHOICE of the GeneralName".  This instance
-- generates roleAuthority as a non-empty list of GeneralNames (always
-- present, wrapped in Just) and roleName as an arbitrary AltName.
-- The roleName is not restricted to URI here, allowing the profile
-- validator's RoleNameNotURI warning to be exercised.
--
-- Expected: roleAuthority is always present; roleName may be any AltName.
-- NOT generated: roleAuthority = Nothing cases.
instance Arbitrary RoleSyntax where
  arbitrary = (RoleSyntax . Just <$> listOf1NonEmpty arbitrary) <*> arbitrary

-- | Arbitrary instance for Attr_Role (RFC 5755 §4.4.5)
--
-- Attr_Role wraps a RoleSyntax value as an AC attribute.  RFC 5755 §4.4.5
-- defines the id-at-role OID (2.5.4.72) and the encoding rules for role
-- attributes within the AC's SEQUENCE OF Attribute.  This instance simply
-- delegates to the RoleSyntax Arbitrary instance.
instance Arbitrary Attr_Role where
  arbitrary = Attr_Role <$> arbitrary

-- | Arbitrary instance for ClassListFlag (RFC 5755 §4.4.6)
--
-- RFC 5755 §4.4.6 (Clearance):
--   ClassList ::= BIT STRING {
--     unmarked       (0),
--     unclassified   (1),
--     restricted     (2),
--     confidential   (3),
--     secret         (4),
--     topSecret      (5)
--   }
--
-- This instance generates one of the six classification levels uniformly,
-- covering the full range of the ClassList BIT STRING enumeration.
instance Arbitrary ClassListFlag where
  arbitrary = elements [ClassList_unmarked .. ClassList_topSecret]

-- | Arbitrary instance for Attributes (RFC 5755 §4.2.7)
--
-- RFC 5755 §4.2.7:
--   attributes  SEQUENCE OF Attribute
--
-- This instance always generates an empty attribute sequence.  This is
-- intentional: individual property tests that need specific attributes
-- (e.g., role attributes) construct them directly via makeTestACIWithAttributes
-- rather than relying on random generation, giving precise control over
-- which attribute combinations are tested.
instance Arbitrary Attributes where
  arbitrary = return $ Attributes []

-- Test Tree

-- | QuickCheck property tests for RFC 5755 Profile Validation.
--
-- These tests verify that validateRFC5755Profile correctly enforces:
-- - §4.2.3 Issuer: v1Form rejected, v2Form accepted with constraints
-- - §4.2.5 Serial Number: must be positive
-- - §4.2.2 Holder: at least one identification method required
-- - §4.3   Extensions: unknown critical extensions rejected
-- - §4.4.5 Role: roleName should use URI form
-- - Signature algorithm: MD5 rejected, SHA1 deprecated, SHA256+ accepted
tests :: TestTree
tests =
  testGroup
    "AC Validation Tests"
    [ testGroup
        "RFC 5755 Profile Validation"
        [ testProperty "v1Form is rejected" prop_v1Form_rejected,
          testProperty "v2Form with valid issuerName passes" prop_v2Form_valid_issuerName_passes,
          testProperty "serial number validation" prop_serial_number_validation,
          testProperty "holder with at least one field passes" prop_holder_with_field_passes,
          testProperty "holder with all fields empty fails" prop_holder_empty_fails,
          testProperty "v2Form baseCertificateID present fails" prop_v2Form_baseCertID_fails,
          testProperty "v2Form objectDigestInfo present fails" prop_v2Form_objDigest_fails,
          testProperty "unknown critical extension is rejected" prop_unknown_critical_ext_rejected,
          testProperty "known critical extension passes" prop_known_critical_ext_passes,
          testProperty "non-critical unknown extension passes" prop_noncritical_unknown_ext_passes,
          testProperty "role with URI name passes" prop_role_uri_passes,
          testProperty "role with non-URI name produces warning" prop_role_nonuri_warns,
          testProperty "MD5 signature is rejected" prop_md5_rejected,
          testProperty "SHA1 signature produces warning" prop_sha1_warning,
          testProperty "SHA256 signature passes" prop_sha256_passes
        ]
    ]

-- Validation Properties

-- | Helper: construct a minimal AttributeCertificateInfo for testing.
--
-- Builds an ACI (RFC 5755 §4.1, §4.2) with the provided holder, issuer,
-- and serial number, filling in default values for all other fields:
--
--   - version:        v2 (1) per RFC 5755 §4.2.1
--   - signature:      SHA256withRSA (acceptable per implementation security policy)
--   - validity:       2020-01-01 to 2025-01-01
--   - attributes:     empty SEQUENCE OF Attribute
--   - issuerUniqueID: absent (OPTIONAL, omitted)
--   - extensions:     absent (Extensions Nothing)
--
-- This helper is the foundation for most property tests: the caller
-- varies the field under test (holder, issuer, serial) while the rest
-- of the ACI remains in a known-good baseline state.
makeTestACI :: Holder -> AttCertIssuer -> Integer -> AttributeCertificateInfo
makeTestACI holder issuer sn = AttributeCertificateInfo
  { aciVersion = 1
  , aciHolder = holder
  , aciIssuer = issuer
  , aciSignature = SignatureALG HashSHA256 PubKeyALG_RSA
  , aciSerialNumber = sn
  , aciValidity = AttCertValidityPeriod
      (DateTime (Date 2020 January 1) (TimeOfDay 0 0 0 0))
      (DateTime (Date 2025 January 1) (TimeOfDay 0 0 0 0))
  , aciAttributes = Attributes []
  , aciIssuerUniqueID = Nothing
  , aciExtensions = Extensions Nothing
  }

-- | Helper: generate a fully RFC 5755 §4.2.3-compliant V2Form issuer.
--
-- Produces an AttCertIssuerV2 with:
--   - issuerName: exactly one directoryName with a non-empty DN
--   - baseCertificateID: Nothing (absent, as required by the profile)
--   - objectDigestInfo:  Nothing (absent, as required by the profile)
--
-- This generator is used in tests that need a known-good issuer so that
-- the property under test can focus on a different ACI field (e.g.,
-- serial number, holder, extensions, or signature algorithm).
genValidV2FormIssuer :: Gen AttCertIssuer
genValidV2FormIssuer = do
  dn <- suchThat arbitrary (\(DistinguishedName l) -> not (null l))
  let v2 = V2Form [AltDirectoryName dn] Nothing Nothing
  return $ AttCertIssuerV2 v2

-- | Helper: generate a valid Holder with baseCertificateID present.
--
-- RFC 5755 §4.2.2 requires at least one of {baseCertificateID,
-- entityName, objectDigestInfo} to be present.  This generator always
-- populates baseCertificateID (the most common identification method
-- for ACs that reference an existing PKC) and leaves entityName and
-- objectDigestInfo absent.
--
-- Used in tests that need a known-good holder so the property under
-- test can focus on other ACI fields without triggering
-- HolderMissingAllFields.
genValidHolder :: Gen Holder
genValidHolder = do
  is <- arbitrary
  return $ Holder (Just is) Nothing Nothing

-- | RFC 5755 §4.2.3: v1Form MUST NOT be used
--
-- RFC 5755 Section 4.2.3 defines:
--   AttCertIssuer ::= CHOICE {
--     v1Form   GeneralNames,     -- MUST NOT be used in this profile
--     v2Form   [0] V2Form        -- v2 only
--   }
--
-- Per RFC 5755: "ACs conforming to this profile MUST use the v2Form choice,
-- which MUST contain one and only one GeneralName in the issuerName"
--
-- What is verified:
--   Constructing an ACI with AttCertIssuerV1 and running validateRFC5755Profile
--   produces V1FormNotAllowed in the error list. This confirms that the
--   profile validator correctly rejects the deprecated v1Form issuer format.
--
-- Expected: V1FormNotAllowed ∈ vrErrors result
-- NOT verified: Whether a DER-encoded AC with v1Form issuer is correctly
--   parsed — that is tested by ASN.1 roundtrip tests in crypton-x509.
prop_v1Form_rejected :: Property
prop_v1Form_rejected = forAll (listOf1NonEmpty arbitrary) $ \gns -> do
  let issuer = AttCertIssuerV1 gns
  let holder = Holder (Just $ IssuerSerial [AltNameDNS "test"] 1 Nothing) Nothing Nothing
  let aci = makeTestACI holder issuer 1
  let result = validateRFC5755Profile aci
  V1FormNotAllowed `elem` vrErrors result

-- | RFC 5755 §4.2.3: v2Form with exactly one directoryName passes
--
-- RFC 5755 §4.2.3 requires:
--   "ACs conforming to this profile MUST use the v2Form choice, which
--    MUST contain one and only one GeneralName in the issuerName, and
--    that GeneralName MUST be of type directoryName."
--
-- What is verified:
--   An ACI constructed with a valid V2Form issuer (one directoryName,
--   no baseCertificateID, no objectDigestInfo) does not produce
--   V1FormNotAllowed, IssuerNameNotSingleDirectoryName, or
--   IssuerDirectoryNameEmpty errors.
--
-- Expected: No issuer-related errors in vrErrors result.
-- NOT verified: Other error categories (e.g., serial number, holder).
prop_v2Form_valid_issuerName_passes :: Property
prop_v2Form_valid_issuerName_passes = forAll genValidV2FormIssuer $ \issuer ->
  forAll genValidHolder $ \holder -> do
    let aci = makeTestACI holder issuer 1
    let result = validateRFC5755Profile aci
    not (V1FormNotAllowed `elem` vrErrors result)
      && not (any isIssuerNameError (vrErrors result))
  where
    isIssuerNameError (IssuerNameNotSingleDirectoryName _) = True
    isIssuerNameError IssuerDirectoryNameEmpty = True
    isIssuerNameError _ = False

-- | RFC 5755 §4.2.5: Serial number MUST be a positive INTEGER
--
-- RFC 5755 §4.2.5:
--   "The serial number MUST be a positive integer assigned by the AC
--    issuer.  It MUST be unique for each AC issued by a given AC issuer."
--
-- What is verified:
--   An ACI with a positive serial number (guaranteed by QuickCheck's
--   Positive wrapper) does not produce SerialNumberNotPositive in the
--   error list.  This confirms the validator accepts conforming serial
--   numbers.
--
-- Expected: SerialNumberNotPositive sn ∉ vrErrors result
-- NOT verified: Non-positive serial numbers (0 or negative).  A separate
--   test would be needed to confirm that SerialNumberNotPositive is raised
--   for sn <= 0.
prop_serial_number_validation :: Positive Integer -> Property
prop_serial_number_validation (Positive sn) =
  forAll genValidV2FormIssuer $ \issuer ->
    forAll genValidHolder $ \holder -> do
      let aci = makeTestACI holder issuer sn
      let result = validateRFC5755Profile aci
      not (SerialNumberNotPositive sn `elem` vrErrors result)

-- | RFC 5755 §4.2.2: Holder with at least one field passes
--
-- RFC 5755 §4.2.2:
--   Holder ::= SEQUENCE {
--     baseCertificateID   [0] IssuerSerial OPTIONAL,
--     entityName          [1] GeneralNames OPTIONAL,
--     objectDigestInfo    [2] ObjectDigestInfo OPTIONAL
--   }
--
-- Per RFC 5755: "At least one of the three options MUST be used for any
-- given AC."
--
-- What is verified:
--   A Holder generated by genValidHolder (which always has baseCertificateID
--   present) does not produce HolderMissingAllFields in the error list.
--
-- Expected: HolderMissingAllFields ∉ vrErrors result
-- NOT verified: Holders with only entityName or only objectDigestInfo
--   (those should also pass but are not exercised by this specific test).
prop_holder_with_field_passes :: Property
prop_holder_with_field_passes = forAll genValidHolder $ \holder ->
  forAll genValidV2FormIssuer $ \issuer -> do
    let aci = makeTestACI holder issuer 1
    let result = validateRFC5755Profile aci
    not (HolderMissingAllFields `elem` vrErrors result)

-- | RFC 5755 §4.2.2: Holder with all fields empty MUST fail
--
-- Per RFC 5755 §4.2.2: "At least one of the three options MUST be used
-- for any given AC."  A Holder with baseCertificateID = Nothing,
-- entityName = Nothing, and objectDigestInfo = Nothing violates this
-- requirement.
--
-- What is verified:
--   Constructing a Holder with all three fields as Nothing and running
--   validateRFC5755Profile produces HolderMissingAllFields in the error list.
--
-- Expected: HolderMissingAllFields ∈ vrErrors result
-- NOT verified: Whether the ASN.1 encoder rejects an empty Holder at the
--   encoding level (that would be a separate DER encoding test).
prop_holder_empty_fails :: Property
prop_holder_empty_fails = forAll genValidV2FormIssuer $ \issuer -> do
  let holder = Holder Nothing Nothing Nothing
  let aci = makeTestACI holder issuer 1
  let result = validateRFC5755Profile aci
  HolderMissingAllFields `elem` vrErrors result

-- | RFC 5755 §4.2.3: V2Form with baseCertificateID present MUST fail
--
-- RFC 5755 §4.2.3:
--   "baseCertificateID and objectDigestInfo MUST NOT be present."
--
-- What is verified:
--   A V2Form issuer that has baseCertificateID set to Just (an arbitrary
--   IssuerSerial) triggers V2FormBaseCertificateIDPresent in the error list.
--   The issuerName is still a valid single directoryName, so this test
--   isolates the baseCertificateID violation.
--
-- Expected: V2FormBaseCertificateIDPresent ∈ vrErrors result
-- NOT verified: The case where both baseCertificateID and objectDigestInfo
--   are simultaneously present (that would also fail, but for two reasons).
prop_v2Form_baseCertID_fails :: Property
prop_v2Form_baseCertID_fails =
  forAll arbitrary $ \is ->
    forAll (suchThat arbitrary (\(DistinguishedName l) -> not (null l))) $ \dn ->
      forAll genValidHolder $ \holder -> do
        let v2 = V2Form [AltDirectoryName dn] (Just is) Nothing
        let issuer = AttCertIssuerV2 v2
        let aci = makeTestACI holder issuer 1
        let result = validateRFC5755Profile aci
        V2FormBaseCertificateIDPresent `elem` vrErrors result

-- | RFC 5755 §4.2.3: V2Form with objectDigestInfo present MUST fail
--
-- RFC 5755 §4.2.3:
--   "baseCertificateID and objectDigestInfo MUST NOT be present."
--
-- What is verified:
--   A V2Form issuer that has objectDigestInfo set to Just (an arbitrary
--   ObjectDigestInfo) triggers V2FormObjectDigestInfoPresent in the error
--   list.  The issuerName is still a valid single directoryName, and
--   baseCertificateID is Nothing, so this test isolates the
--   objectDigestInfo violation.
--
-- Expected: V2FormObjectDigestInfoPresent ∈ vrErrors result
-- NOT verified: The case where both objectDigestInfo and baseCertificateID
--   are simultaneously present.
prop_v2Form_objDigest_fails :: Property
prop_v2Form_objDigest_fails =
  forAll arbitrary $ \odi ->
    forAll (suchThat arbitrary (\(DistinguishedName l) -> not (null l))) $ \dn ->
      forAll genValidHolder $ \holder -> do
        let v2 = V2Form [AltDirectoryName dn] Nothing (Just odi)
        let issuer = AttCertIssuerV2 v2
        let aci = makeTestACI holder issuer 1
        let result = validateRFC5755Profile aci
        V2FormObjectDigestInfoPresent `elem` vrErrors result

-- Critical Extension Validation Properties

-- | Helper: construct a minimal ExtensionRaw with the given OID and criticality.
--
-- RFC 5755 §4.3 (Extensions):
--   Extension ::= SEQUENCE {
--     extnID      OBJECT IDENTIFIER,
--     critical    BOOLEAN DEFAULT FALSE,
--     extnValue   OCTET STRING
--   }
--
-- The extension value is always B.empty because these tests exercise
-- the profile validator's OID recognition and criticality checking,
-- not the parsing of extension-specific payloads.
makeTestExtension :: OID -> Bool -> ExtensionRaw
makeTestExtension oid critical = ExtensionRaw oid critical B.empty

-- | Helper: construct an ACI with a specific set of extensions.
--
-- Builds a baseline-valid ACI (v2Form issuer with one directoryName,
-- valid holder, positive serial, SHA256withRSA signature) and injects
-- the provided list of ExtensionRaw values into the aciExtensions field.
--
-- This allows extension-related property tests to focus exclusively on
-- the extension validation logic (RFC 5755 §4.3) without triggering
-- errors from other ACI fields.
--
-- RFC 5755 §4.3: "If an AC contains a critical extension that the AC
-- user cannot process, the AC MUST be rejected."
makeTestACIWithExtensions :: [ExtensionRaw] -> AttributeCertificateInfo
makeTestACIWithExtensions exts =
  let holder = Holder (Just $ IssuerSerial [AltNameDNS "test"] 1 Nothing) Nothing Nothing
      dn = DistinguishedName [(getObjectID DnCommonName, ASN1CharacterString UTF8 "Test Issuer")]
      issuer = AttCertIssuerV2 $ V2Form [AltDirectoryName dn] Nothing Nothing
  in AttributeCertificateInfo
       { aciVersion = 1
       , aciHolder = holder
       , aciIssuer = issuer
       , aciSignature = SignatureALG HashSHA256 PubKeyALG_RSA
       , aciSerialNumber = 1
       , aciValidity = AttCertValidityPeriod
           (DateTime (Date 2020 January 1) (TimeOfDay 0 0 0 0))
           (DateTime (Date 2025 January 1) (TimeOfDay 0 0 0 0))
       , aciAttributes = Attributes []
       , aciIssuerUniqueID = Nothing
       , aciExtensions = Extensions (Just exts)
       }

-- | RFC 5755 §4.3: Unknown critical extension MUST be rejected
--
-- RFC 5755 §4.3 (referencing RFC 5280 §4.2):
--   "If an AC contains a critical extension that the AC user cannot
--    process, the AC MUST be rejected."
--
-- What is verified:
--   An ACI containing a single extension with OID 1.2.3.4.5.6.7.8.9
--   (not in the set of known/recognized OIDs) marked as critical=True
--   produces UnknownCriticalExtension [1,2,3,4,5,6,7,8,9] in the error
--   list.
--
-- Expected: UnknownCriticalExtension unknownOID ∈ vrErrors result
-- NOT verified: The behavior when multiple unknown critical extensions
--   are present (each should be independently reported).
prop_unknown_critical_ext_rejected :: Property
prop_unknown_critical_ext_rejected = property $ do
  let unknownOID = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  let ext = makeTestExtension unknownOID True
  let aci = makeTestACIWithExtensions [ext]
  let result = validateRFC5755Profile aci
  UnknownCriticalExtension unknownOID `elem` vrErrors result

-- | RFC 5755 §4.3: Known critical extension is accepted
--
-- RFC 5755 §4.3 lists recognized extension OIDs, including:
--   - id-ce-authorityKeyIdentifier (2.5.29.35) from RFC 5280 §4.2.1.1
--
-- What is verified:
--   An ACI containing a single extension with OID 2.5.29.35 (Authority
--   Key Identifier) marked as critical=True does NOT produce any
--   UnknownCriticalExtension errors.  The validator recognizes this OID
--   as a known extension and does not reject it.
--
-- Expected: No UnknownCriticalExtension errors in vrErrors result.
-- NOT verified: Whether the extension value is correctly parsed or
--   whether the extension semantics are enforced (only OID recognition
--   and criticality handling are tested).
prop_known_critical_ext_passes :: Property
prop_known_critical_ext_passes = property $ do
  let knownOID = [2, 5, 29, 35]
  let ext = makeTestExtension knownOID True
  let aci = makeTestACIWithExtensions [ext]
  let result = validateRFC5755Profile aci
  not $ any isUnknownCriticalExtError (vrErrors result)
  where
    isUnknownCriticalExtError (UnknownCriticalExtension _) = True
    isUnknownCriticalExtError _ = False

-- | RFC 5755 §4.3: Non-critical unknown extension is tolerated
--
-- RFC 5280 §4.2 (referenced by RFC 5755 §4.3):
--   "A certificate-using system MUST reject the certificate if it
--    encounters a critical extension it does not recognize; however,
--    a non-critical extension may be ignored if it is not recognized."
--
-- What is verified:
--   An ACI containing a single extension with unknown OID 1.2.3.4.5.6.7.8.9
--   marked as critical=False does NOT produce any UnknownCriticalExtension
--   errors.  Non-critical extensions are allowed to be unrecognized.
--
-- Expected: No UnknownCriticalExtension errors in vrErrors result.
-- NOT verified: Whether the unknown non-critical extension is silently
--   ignored or logged as an informational message.
prop_noncritical_unknown_ext_passes :: Property
prop_noncritical_unknown_ext_passes = property $ do
  let unknownOID = [1, 2, 3, 4, 5, 6, 7, 8, 9]
  let ext = makeTestExtension unknownOID False
  let aci = makeTestACIWithExtensions [ext]
  let result = validateRFC5755Profile aci
  not $ any isUnknownCriticalExtError (vrErrors result)
  where
    isUnknownCriticalExtError (UnknownCriticalExtension _) = True
    isUnknownCriticalExtError _ = False

-- Role Attribute Validation Properties

-- | Helper: construct an ACI with a specific set of attributes.
--
-- Builds a baseline-valid ACI (v2Form issuer, valid holder, positive
-- serial, SHA256withRSA, no extensions) and injects the provided
-- Attributes into the aciAttributes field.
--
-- This allows attribute-related property tests (RFC 5755 §4.4) to focus
-- on attribute validation without triggering errors from other ACI fields.
-- In particular, role attribute tests (§4.4.5) use this helper to inject
-- Attr_Role values and verify RoleNameNotURI warnings.
makeTestACIWithAttributes :: Attributes -> AttributeCertificateInfo
makeTestACIWithAttributes attrs =
  let holder = Holder (Just $ IssuerSerial [AltNameDNS "test"] 1 Nothing) Nothing Nothing
      dn = DistinguishedName [(getObjectID DnCommonName, ASN1CharacterString UTF8 "Test Issuer")]
      issuer' = AttCertIssuerV2 $ V2Form [AltDirectoryName dn] Nothing Nothing
  in AttributeCertificateInfo
       { aciVersion = 1
       , aciHolder = holder
       , aciIssuer = issuer'
       , aciSignature = SignatureALG HashSHA256 PubKeyALG_RSA
       , aciSerialNumber = 1
       , aciValidity = AttCertValidityPeriod
           (DateTime (Date 2020 January 1) (TimeOfDay 0 0 0 0))
           (DateTime (Date 2025 January 1) (TimeOfDay 0 0 0 0))
       , aciAttributes = attrs
       , aciIssuerUniqueID = Nothing
       , aciExtensions = Extensions Nothing
       }

-- | RFC 5755 §4.4.5: Role with URI roleName passes without warning
--
-- RFC 5755 §4.4.5:
--   RoleSyntax ::= SEQUENCE {
--     roleAuthority  [0] GeneralNames OPTIONAL,
--     roleName       [1] GeneralName
--   }
--
-- Per RFC 5755: "roleName MUST be present and roleName MUST use the
-- uniformResourceIdentifier CHOICE of the GeneralName."
--
-- What is verified:
--   An ACI with a role attribute whose roleName is AltNameURI
--   "http://example.com/role/admin" does not produce a RoleNameNotURI
--   warning.  This confirms the validator accepts the recommended URI form.
--
-- Expected: RoleNameNotURI ∉ vrWarnings result
-- NOT verified: Whether the URI is syntactically valid per RFC 3986.
prop_role_uri_passes :: Property
prop_role_uri_passes = property $ do
  let roleAttr = Attr_Role $ RoleSyntax Nothing (AltNameURI "http://example.com/role/admin")
  let attrs = Attributes [encodeAttribute [roleAttr]]
  let aci = makeTestACIWithAttributes attrs
  let result = validateRFC5755Profile aci
  not (RoleNameNotURI `elem` vrWarnings result)

-- | RFC 5755 §4.4.5: Role with non-URI roleName produces warning
--
-- RFC 5755 §4.4.5 states that roleName "MUST use the
-- uniformResourceIdentifier CHOICE of the GeneralName."  Using a
-- different GeneralName form (e.g., dNSName) is non-conforming.
--
-- What is verified:
--   An ACI with a role attribute whose roleName is AltNameDNS
--   "admin.example.com" (not a URI) produces RoleNameNotURI in the
--   warnings list.  This is a warning rather than an error because
--   the AC may still be usable in some contexts.
--
-- Expected: RoleNameNotURI ∈ vrWarnings result
-- NOT verified: Other non-URI GeneralName forms (iPAddress, rfc822Name,
--   etc.) — they should all produce the same warning.
prop_role_nonuri_warns :: Property
prop_role_nonuri_warns = property $ do
  let roleAttr = Attr_Role $ RoleSyntax Nothing (AltNameDNS "admin.example.com")
  let attrs = Attributes [encodeAttribute [roleAttr]]
  let aci = makeTestACIWithAttributes attrs
  let result = validateRFC5755Profile aci
  RoleNameNotURI `elem` vrWarnings result

-- Signature Algorithm Validation Properties

-- | Helper: construct an ACI with a specific signature algorithm.
--
-- Builds a baseline-valid ACI (v2Form issuer, valid holder, positive
-- serial, no attributes, no extensions) and sets aciSignature to the
-- provided SignatureALG value.
--
-- This allows signature algorithm property tests to focus exclusively on
-- the validator's handling of weak, deprecated, and acceptable algorithms.
--
-- RFC 5755 §8 (Security Considerations) recommends that relying parties
-- reject ACs signed with weak algorithms (e.g., MD5) and deprecate
-- others (e.g., SHA-1).
makeTestACIWithSigAlg :: SignatureALG -> AttributeCertificateInfo
makeTestACIWithSigAlg sigAlg =
  let holder = Holder (Just $ IssuerSerial [AltNameDNS "test"] 1 Nothing) Nothing Nothing
      dn = DistinguishedName [(getObjectID DnCommonName, ASN1CharacterString UTF8 "Test Issuer")]
      issuer' = AttCertIssuerV2 $ V2Form [AltDirectoryName dn] Nothing Nothing
  in AttributeCertificateInfo
       { aciVersion = 1
       , aciHolder = holder
       , aciIssuer = issuer'
       , aciSignature = sigAlg
       , aciSerialNumber = 1
       , aciValidity = AttCertValidityPeriod
           (DateTime (Date 2020 January 1) (TimeOfDay 0 0 0 0))
           (DateTime (Date 2025 January 1) (TimeOfDay 0 0 0 0))
       , aciAttributes = Attributes []
       , aciIssuerUniqueID = Nothing
       , aciExtensions = Extensions Nothing
       }

-- | Security best practices: MD5 signature algorithm MUST be rejected
--
-- MD5 is cryptographically broken (collision attacks demonstrated since
-- 2004).  Per security best practices (see also RFC 5755 §8), ACs
-- signed with MD5-based algorithms must be rejected.
--
-- What is verified:
--   An ACI with aciSignature = SignatureALG HashMD5 PubKeyALG_RSA
--   produces WeakSignatureAlgorithm "MD5" in the error list.
--
-- Expected: WeakSignatureAlgorithm "MD5" ∈ vrErrors result
-- NOT verified: Other weak algorithms (e.g., MD2, MD4) that should also
--   be rejected.
prop_md5_rejected :: Property
prop_md5_rejected = property $ do
  let aci = makeTestACIWithSigAlg (SignatureALG HashMD5 PubKeyALG_RSA)
  let result = validateRFC5755Profile aci
  WeakSignatureAlgorithm "MD5" `elem` vrErrors result

-- | Security best practices: SHA-1 signature algorithm produces deprecation warning
--
-- SHA-1 has known theoretical weaknesses and practical collision attacks
-- (SHAttered, 2017).  While not as broken as MD5, SHA-1 is deprecated
-- for new signatures.  The profile validator treats it as a warning
-- rather than an error, allowing existing ACs to be processed with
-- appropriate caution.
--
-- What is verified:
--   An ACI with aciSignature = SignatureALG HashSHA1 PubKeyALG_RSA
--   produces DeprecatedSignatureAlgorithm "SHA1" in the warnings list.
--
-- Expected: DeprecatedSignatureAlgorithm "SHA1" ∈ vrWarnings result
-- NOT verified: Whether the warning is escalated to an error in strict
--   validation mode (if such a mode exists).
prop_sha1_warning :: Property
prop_sha1_warning = property $ do
  let aci = makeTestACIWithSigAlg (SignatureALG HashSHA1 PubKeyALG_RSA)
  let result = validateRFC5755Profile aci
  DeprecatedSignatureAlgorithm "SHA1" `elem` vrWarnings result

-- | Security best practices: SHA-256 signature algorithm passes without errors or warnings
--
-- SHA-256 is currently considered secure and is the minimum recommended
-- hash algorithm for new AC signatures.  The profile validator should
-- accept it without producing any WeakSignatureAlgorithm errors or
-- DeprecatedSignatureAlgorithm warnings.
--
-- What is verified:
--   An ACI with aciSignature = SignatureALG HashSHA256 PubKeyALG_RSA
--   produces no WeakSignatureAlgorithm errors and no
--   DeprecatedSignatureAlgorithm warnings.
--
-- Expected: No signature-related errors or warnings in the result.
-- NOT verified: SHA-384 and SHA-512 (they should also pass, and are
--   covered by the SignatureALG Arbitrary instance in general tests).
prop_sha256_passes :: Property
prop_sha256_passes = property $ do
  let aci = makeTestACIWithSigAlg (SignatureALG HashSHA256 PubKeyALG_RSA)
  let result = validateRFC5755Profile aci
  not (any isWeakSigAlgError (vrErrors result))
    && not (any isDeprecatedSigAlgWarning (vrWarnings result))
  where
    isWeakSigAlgError (WeakSignatureAlgorithm _) = True
    isWeakSigAlgError _ = False
    isDeprecatedSigAlgWarning (DeprecatedSignatureAlgorithm _) = True
    isDeprecatedSigAlgWarning _ = False
